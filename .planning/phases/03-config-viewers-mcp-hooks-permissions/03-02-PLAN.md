---
phase: 03-config-viewers-mcp-hooks-permissions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/types.ts
  - src/hooks/resolver.ts
  - src/commands/hooks.ts
  - src/commands/commands.ts
  - src/formatters/hooks.ts
  - src/formatters/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can see all configured hooks with event types, matchers, and commands"
    - "User can see all available hook events with configured vs unconfigured status"
    - "User can list all custom commands/skills with their file locations"
    - "--json output includes all hooks and commands data in machine-readable format"
  artifacts:
    - path: "src/hooks/types.ts"
      provides: "Hook event, config, and result type definitions"
      exports: ["HookEntry", "HookMatcher", "HookEvent", "HooksResult"]
    - path: "src/hooks/resolver.ts"
      provides: "Hook extraction from settings and event catalog"
      exports: ["extractHooks"]
    - path: "src/commands/hooks.ts"
      provides: "CLI hooks command"
      exports: ["hooksCommand"]
    - path: "src/commands/commands.ts"
      provides: "CLI commands command for slash commands and skills"
      exports: ["commandsCommand"]
    - path: "src/formatters/hooks.ts"
      provides: "Table and JSON formatters for hooks and commands"
      exports: ["formatHooksTable", "formatHooksJson", "formatCommandsTable", "formatCommandsJson"]
  key_links:
    - from: "src/commands/hooks.ts"
      to: "src/hooks/resolver.ts"
      via: "extractHooks() call"
      pattern: "extractHooks"
    - from: "src/hooks/resolver.ts"
      to: "scan result files"
      via: "filters ConfigFile[] for settings with hooks key"
      pattern: "f\\.content.*hooks"
---

<objective>
Implement `claude-ctl hooks` and `claude-ctl commands` commands for viewing configured hooks with event catalog and listing custom slash commands/skills.

Purpose: Give users visibility into all hooks (event types, matchers, commands) and custom commands/skills (HOOK-01, HOOK-02, HOOK-03).
Output: Working `hooks` and `commands` commands with table and JSON output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/scanner/types.ts
@src/scanner/paths.ts
@src/scanner/index.ts
@src/commands/memory.ts
@src/formatters/index.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hooks types + resolver with event catalog</name>
  <files>src/hooks/types.ts, src/hooks/resolver.ts</files>
  <action>
    **1. Create hooks types** (`src/hooks/types.ts`):
    ```typescript
    import type { ConfigScope } from "../scanner/types.js";

    export interface HookEntry {
      type: "command";
      command: string;
      async?: boolean;
    }

    export interface HookMatcher {
      matcher?: string;        // Pipe-separated pattern (e.g., "Edit|Write|MultiEdit")
      hooks: HookEntry[];
    }

    export interface HookEvent {
      event: string;           // Event name (e.g., "PreToolUse", "SessionStart")
      matchers: HookMatcher[];
      scope: ConfigScope;
      sourcePath: string;
    }

    export interface CommandEntry {
      name: string;            // Command/skill name (filename without .md)
      path: string;            // Absolute file path
      scope: ConfigScope;      // user or project
    }

    export interface HooksResult {
      events: HookEvent[];
      availableEvents: string[];    // All known Claude Code hook events
      configuredEvents: string[];   // Events that have at least one hook
      unconfiguredEvents: string[]; // Events without any hooks
    }

    export interface CommandsResult {
      commands: CommandEntry[];
    }
    ```

    **2. Create hooks resolver** (`src/hooks/resolver.ts`):
    Export `extractHooks(files: ConfigFile[]): HooksResult`
    Export `extractCommands(files: ConfigFile[]): CommandsResult`

    **extractHooks logic:**
    a. Define KNOWN_HOOK_EVENTS constant array: ["PreToolUse", "PostToolUse", "Notification", "Stop", "SubagentStop", "SessionStart"]
    b. Filter ConfigFile[] for type === "settings" with exists && readable && content
    c. For each settings file, check if content (as object) has a "hooks" key
    d. If hooks key exists, iterate its keys (event names). For each event:
       - Parse the array of matcher objects: each has optional `matcher` string and `hooks` array
       - Each hook entry has `type`, `command`, optional `async`
       - Create HookEvent with event name, matchers, scope from the settings file, sourcePath
    e. Compute configured vs unconfigured:
       - configuredEvents = unique event names found in any settings file
       - unconfiguredEvents = KNOWN_HOOK_EVENTS minus configuredEvents
       - availableEvents = KNOWN_HOOK_EVENTS
    f. Return HooksResult sorted by event name

    **extractCommands logic:**
    a. Filter ConfigFile[] for type === "commands-dir" with exists && readable
    b. For each commands directory, read its contents using fs.readdir
    c. For each .md file found, create CommandEntry with:
       - name: filename without .md extension
       - path: absolute path to the file
       - scope: from the parent ConfigFile
    d. Also check for skill directories (directories inside commands that contain skill files)
    e. Return CommandsResult sorted by scope priority then name

    Import fs from "node:fs/promises" and path from "node:path" for directory reading.
  </action>
  <verify>npx tsc --noEmit passes with no errors on the new files</verify>
  <done>Hooks resolver extracts hooks from settings.json, catalogs all known events, identifies configured vs unconfigured. Commands resolver lists custom commands from commands directories.</done>
</task>

<task type="auto">
  <name>Task 2: Hooks + commands CLI commands and formatters</name>
  <files>src/commands/hooks.ts, src/commands/commands.ts, src/formatters/hooks.ts, src/formatters/index.ts, src/index.ts</files>
  <action>
    **1. Create hooks/commands formatters** (`src/formatters/hooks.ts`):

    `formatHooksTable(result: HooksResult, projectDir: string | null): string`
    - Title: "Configured Hooks" with chalk.bold
    - For each event in result.events:
      - Event name in bold cyan
      - For each matcher: show matcher pattern (or "all" if no matcher), indented
      - For each hook entry: show command, indented further
      - Show scope and source path in dim
    - After configured hooks, show event catalog section:
      - "Event Catalog:" header
      - For each available event: ✓ if configured, ✗ if unconfigured
    - Empty state: "No hooks configured."
    - Use shortenPath helper for paths (replicate home→~ logic or import from table.ts)

    `formatHooksJson(result: HooksResult): string`
    - JSON.stringify the HooksResult with indent 2

    `formatCommandsTable(result: CommandsResult, projectDir: string | null): string`
    - Title: "Custom Commands & Skills" with chalk.bold
    - Table with columns: Name, Scope, Path
    - Empty state: "No custom commands found."
    - Use shortenPath for paths

    `formatCommandsJson(result: CommandsResult): string`
    - JSON.stringify the CommandsResult with indent 2

    **2. Create hooks command** (`src/commands/hooks.ts`):
    Follow exact pattern from settings/memory commands:
    - `program.command("hooks [project-dir]")`
    - `.description("Show all configured hooks with event types, matchers, and event catalog")`
    - Action: scan(dir), call extractHooks(result.files), format with formatHooks dispatch
    - Output via process.stdout.write

    **3. Create commands command** (`src/commands/commands.ts`):
    - `program.command("commands [project-dir]")`
    - `.description("List all custom slash commands and skills")`
    - Action: scan(dir), call extractCommands(result.files), format with formatCommands dispatch
    - Output via process.stdout.write

    **4. Add dispatches to formatters/index.ts**:
    - Import all 4 formatters from "./hooks.js"
    - Add `formatHooks(result, projectDir, json)` dispatch function
    - Add `formatCommands(result, projectDir, json)` dispatch function
    - Re-export all formatters

    **5. Register commands in src/index.ts**:
    - Import hooksCommand from "./commands/hooks.js"
    - Import commandsCommand from "./commands/commands.js"
    - Call both with program

    Follow established patterns exactly (command registration, formatter dispatch, stdout.write).
  </action>
  <verify>npm run build succeeds && node dist/index.js hooks --help shows usage && node dist/index.js commands --help shows usage && node dist/index.js hooks --json outputs valid JSON</verify>
  <done>`claude-ctl hooks` shows configured hooks with event catalog. `claude-ctl commands` lists custom commands/skills. Both table and --json output work.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] `claude-ctl hooks` runs without error (shows hooks or "No hooks configured")
- [ ] `claude-ctl hooks --json` outputs valid JSON with event catalog
- [ ] `claude-ctl commands` runs without error
- [ ] `claude-ctl commands --json` outputs valid JSON
- [ ] Event catalog shows all known events with configured/unconfigured status
- [ ] `claude-ctl scan` and other existing commands still work (no regressions)
</verification>

<success_criteria>
- All tasks completed
- Hooks from settings.json are extracted and displayed with event types and matchers
- Event catalog shows all known hook events with configured vs unconfigured status
- Custom commands from commands directories are listed with scope and path
- Table and JSON output both work for both commands
- No regressions in existing commands
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-viewers-mcp-hooks-permissions/03-02-SUMMARY.md`
</output>
