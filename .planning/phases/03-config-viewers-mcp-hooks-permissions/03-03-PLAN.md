---
phase: 03-config-viewers-mcp-hooks-permissions
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/permissions/types.ts
  - src/permissions/resolver.ts
  - src/commands/permissions.ts
  - src/formatters/permissions.ts
  - src/formatters/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can see all permissions with their rule type (allow/deny/ask) and source scope"
    - "Permissions are merged with deny > ask > allow priority across scopes"
    - "User can filter permissions by tool name"
    - "Each permission shows its origin file and scope level"
    - "--json output includes all permissions data in machine-readable format"
  artifacts:
    - path: "src/permissions/types.ts"
      provides: "Permission entry and result type definitions"
      exports: ["PermissionEntry", "PermissionsResult"]
    - path: "src/permissions/resolver.ts"
      provides: "Permission extraction and merge with priority logic"
      exports: ["resolvePermissions"]
    - path: "src/commands/permissions.ts"
      provides: "CLI permissions command with --tool filter"
      exports: ["permissionsCommand"]
    - path: "src/formatters/permissions.ts"
      provides: "Table and JSON formatters for permissions"
      exports: ["formatPermissionsTable", "formatPermissionsJson"]
  key_links:
    - from: "src/commands/permissions.ts"
      to: "src/permissions/resolver.ts"
      via: "resolvePermissions() call"
      pattern: "resolvePermissions"
    - from: "src/permissions/resolver.ts"
      to: "scan result files"
      via: "filters ConfigFile[] for settings with permissions key"
      pattern: "f\\.content.*permissions"
---

<objective>
Implement `claude-ctl permissions` command that shows merged permissions across all scopes with deny > ask > allow priority and origin tracking.

Purpose: Give users visibility into the effective permission state for each tool, showing which rules apply and where they come from (PERM-01).
Output: Working `permissions` command with --tool filter and table/JSON output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/scanner/types.ts
@src/scanner/index.ts
@src/commands/settings.ts
@src/settings/resolver.ts
@src/formatters/index.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Permissions types + resolver with scope-aware merge</name>
  <files>src/permissions/types.ts, src/permissions/resolver.ts</files>
  <action>
    **1. Create permissions types** (`src/permissions/types.ts`):
    ```typescript
    import type { ConfigScope } from "../scanner/types.js";

    export interface PermissionEntry {
      tool: string;            // Tool name (e.g., "Bash", "WebSearch", "Skill")
      pattern?: string;        // Pattern if present (e.g., "ls:*", "domain:example.com")
      rule: "allow" | "deny" | "ask";
      scope: ConfigScope;
      sourcePath: string;
      raw: string;             // Original permission string as written in config
    }

    export interface EffectivePermission {
      tool: string;
      pattern?: string;
      effectiveRule: "allow" | "deny" | "ask";
      effectiveScope: ConfigScope;
      effectiveSourcePath: string;
      overrides: PermissionEntry[];  // All entries for this tool+pattern across scopes
    }

    export interface PermissionsResult {
      all: PermissionEntry[];               // All raw permission entries
      effective: EffectivePermission[];     // Merged effective permissions
    }
    ```

    **2. Create permissions resolver** (`src/permissions/resolver.ts`):
    Export `resolvePermissions(files: ConfigFile[]): PermissionsResult`

    **Logic:**
    a. Filter ConfigFile[] for type === "settings" with exists && readable && content
    b. For each settings file, check if content (as object) has a "permissions" key
    c. If permissions key exists, iterate its sub-keys: "allow", "deny", "ask"
    d. For each rule type, parse each permission string:
       - Format: `ToolName` → tool="ToolName", pattern=undefined
       - Format: `ToolName(pattern)` → tool="ToolName", pattern="pattern"
       - Use regex: `/^([^(]+?)(?:\((.+)\))?$/` to parse
       - Store raw string, tool, pattern, rule type, scope, sourcePath
    e. **Merge logic** (deny > ask > allow):
       - Group entries by tool+pattern combination
       - For each group, determine effective rule:
         1. If ANY entry is "deny" → effective = "deny"
         2. Else if ANY entry is "ask" → effective = "ask"
         3. Else → effective = "allow"
       - Within same priority, higher scope wins (local > project > user > managed)
       - Track the winning entry's scope and sourcePath
       - Include all entries as overrides for full chain visibility
    f. Sort effective permissions: by tool name, then pattern

    **Scope priority** (same as settings resolver): managed=0, user=1, project=2, local=3 (higher number = higher priority).

    **Edge cases:**
    - Permission string with no parentheses → tool name only, no pattern
    - Permission string with complex patterns like `Bash(ls "D:/path")` → everything inside parens is the pattern
    - MCP tool names like `mcp__plugin_context7_context7__resolve-library-id` → treat whole thing as tool name
  </action>
  <verify>npx tsc --noEmit passes with no errors on the new files</verify>
  <done>Permissions resolver extracts all permissions from settings files, parses tool+pattern, merges with deny > ask > allow priority, tracks origin per entry</done>
</task>

<task type="auto">
  <name>Task 2: Permissions command + formatters</name>
  <files>src/commands/permissions.ts, src/formatters/permissions.ts, src/formatters/index.ts, src/index.ts</files>
  <action>
    **1. Create permissions formatters** (`src/formatters/permissions.ts`):

    `formatPermissionsTable(result: PermissionsResult, projectDir: string | null): string`
    - Title: "Permissions" with chalk.bold
    - For each effective permission:
      - Tool name (+ pattern if present) in bold
      - Effective rule with color coding: allow=green, deny=red, ask=yellow
      - Source scope and path in dim
      - If overrides.length > 1, show override chain (same pattern as settings override chain):
        - Winning rule in green
        - Overridden rules in dim
        - Use box-drawing chars (├, └) for chain
    - Empty state: "No permissions configured."
    - Footer: summary counts (e.g., "5 allow, 0 deny, 0 ask")
    - Use shortenPath helper for paths (replicate home→~ logic)

    `formatPermissionsJson(result: PermissionsResult): string`
    - JSON.stringify the PermissionsResult with indent 2

    **2. Create permissions command** (`src/commands/permissions.ts`):
    Follow exact pattern from settings command:
    - `program.command("permissions [project-dir]")`
    - `.description("Show merged permissions with deny > ask > allow priority and origin tracking")`
    - `.option("--tool <name>", "Filter to show only permissions matching this tool name (substring match)")`
    - Action: scan(dir), call resolvePermissions(result.files), optionally filter by --tool, format output
    - --tool filter: case-insensitive substring match on tool name (same pattern as settings --key)
    - Output via process.stdout.write

    **3. Add dispatch to formatters/index.ts**:
    - Import formatPermissionsTable, formatPermissionsJson from "./permissions.js"
    - Add `formatPermissions(result, projectDir, json)` dispatch function
    - Re-export formatPermissionsTable, formatPermissionsJson

    **4. Register command in src/index.ts**:
    - Import permissionsCommand from "./commands/permissions.js"
    - Call permissionsCommand(program) alongside other registrations

    Follow established patterns exactly (command registration, formatter dispatch, stdout.write).
  </action>
  <verify>npm run build succeeds && node dist/index.js permissions --help shows usage && node dist/index.js permissions --json outputs valid JSON && node dist/index.js permissions --tool Bash shows filtered results</verify>
  <done>`claude-ctl permissions` shows merged permissions with priority, origin tracking, and override chains. --tool filter works. Both table and --json output work.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] `claude-ctl permissions` runs without error
- [ ] `claude-ctl permissions --json` outputs valid JSON
- [ ] `claude-ctl permissions --tool Bash` filters to Bash permissions only
- [ ] Override chains display correctly when same tool appears at multiple scopes
- [ ] deny rules override allow rules in merged view
- [ ] `claude-ctl scan` and other existing commands still work (no regressions)
</verification>

<success_criteria>
- All tasks completed
- Permissions from all settings files are extracted and parsed
- Merge logic correctly applies deny > ask > allow priority
- Override chains show when same tool configured at multiple scopes
- --tool filter works with case-insensitive substring matching
- Table and JSON output both work
- No regressions in existing commands
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-viewers-mcp-hooks-permissions/03-03-SUMMARY.md`
</output>
