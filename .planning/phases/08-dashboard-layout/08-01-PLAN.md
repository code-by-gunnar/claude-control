---
phase: 08-dashboard-layout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dashboard/src/components/Sidebar.tsx
  - dashboard/src/components/Layout.tsx
  - dashboard/src/lib/refresh-context.tsx
  - dashboard/src/App.tsx
  - dashboard/src/pages/OverviewPage.tsx
  - dashboard/src/pages/SettingsPage.tsx
  - dashboard/src/pages/MemoryPage.tsx
  - dashboard/src/pages/McpPage.tsx
  - dashboard/src/pages/PluginsPage.tsx
  - dashboard/src/pages/MarketplacesPage.tsx
  - dashboard/src/pages/HooksPage.tsx
  - dashboard/src/pages/AgentsPage.tsx
  - dashboard/src/pages/SkillsPage.tsx
  - dashboard/src/pages/PermissionsPage.tsx
  - dashboard/src/pages/HealthPage.tsx
  - dashboard/src/pages/ProjectsPage.tsx
autonomous: false

must_haves:
  truths:
    - "Sidebar shows items grouped under Configuration, Extensions, and Workspace section headers"
    - "Overview link remains at top of sidebar, ungrouped"
    - "Refresh button is visible in the layout header area on all pages"
    - "Clicking refresh re-fetches the active page's data without full page reload"
    - "Refresh button shows a loading/spinning indicator while data is being fetched"
  artifacts:
    - path: "dashboard/src/components/Sidebar.tsx"
      provides: "Grouped sidebar navigation with section headers"
      contains: "Configuration"
    - path: "dashboard/src/components/Layout.tsx"
      provides: "Layout with header containing refresh button"
      contains: "refreshKey"
    - path: "dashboard/src/lib/refresh-context.tsx"
      provides: "RefreshContext with refreshKey, triggerRefresh, isRefreshing, setRefreshing"
      exports: ["RefreshProvider", "useRefresh"]
  key_links:
    - from: "dashboard/src/lib/refresh-context.tsx"
      to: "dashboard/src/App.tsx"
      via: "RefreshProvider wraps Routes"
      pattern: "RefreshProvider"
    - from: "dashboard/src/components/Layout.tsx"
      to: "dashboard/src/lib/refresh-context.tsx"
      via: "useRefresh hook for triggerRefresh and isRefreshing"
      pattern: "useRefresh"
    - from: "dashboard/src/pages/*.tsx"
      to: "dashboard/src/lib/refresh-context.tsx"
      via: "useRefresh hook for refreshKey in useEffect dependency"
      pattern: "refreshKey"
---

<objective>
Restructure the dashboard sidebar with grouped navigation sections and add a global refresh button.

Purpose: The sidebar has grown to 12 items — grouping under section headers (Configuration, Extensions, Workspace) improves navigation. The refresh button enables the edit-in-terminal, check-in-dashboard workflow without full page reloads.
Output: Grouped sidebar, layout header with refresh button, RefreshContext wiring to all pages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@dashboard/src/components/Sidebar.tsx
@dashboard/src/components/Layout.tsx
@dashboard/src/App.tsx
@dashboard/src/lib/api.ts
@dashboard/src/pages/OverviewPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure sidebar into grouped sections</name>
  <files>dashboard/src/components/Sidebar.tsx</files>
  <action>
    Restructure the flat `navItems` array into a grouped structure with section headers.

    **Group assignments:**
    - **Ungrouped (top)**: Overview
    - **Configuration**: Settings, Memory, Permissions
    - **Extensions**: MCP Servers, Plugins, Marketplaces, Hooks, Agents, Skills
    - **Workspace**: Health, Projects

    **Implementation:**
    1. Replace the flat `navItems: NavItem[]` with a grouped structure:
       ```
       interface NavGroup {
         label: string | null;  // null = ungrouped (Overview)
         items: NavItem[];
       }
       ```
    2. Create `navGroups: NavGroup[]` with the four groups above.
    3. Update the `<nav>` rendering to iterate over groups, rendering:
       - Section header: `<p>` with uppercase text, small font, text-slate-500, px-3, mt-4 mb-1 (skip mt for first group)
       - Items: same `<NavLink>` rendering as before
       - No header for the null-label group (Overview)
    4. Keep all existing NavItem data (routes, labels, icons) exactly as-is. Only change the organization.
    5. Preserve all mobile behavior (hamburger, overlay, click-to-close).

    **Style for section headers:**
    - `text-[11px] font-semibold uppercase tracking-wider text-slate-500 px-3`
    - `mt-5 mb-1` (except first group gets `mt-0`)
    - Non-clickable, non-interactive
  </action>
  <verify>npm run build succeeds with no TypeScript errors</verify>
  <done>Sidebar shows 12 nav items organized under 3 labeled section headers plus ungrouped Overview at top</done>
</task>

<task type="auto">
  <name>Task 2: Create RefreshContext and add refresh button to Layout header</name>
  <files>dashboard/src/lib/refresh-context.tsx, dashboard/src/components/Layout.tsx, dashboard/src/App.tsx, dashboard/src/pages/OverviewPage.tsx, dashboard/src/pages/SettingsPage.tsx, dashboard/src/pages/MemoryPage.tsx, dashboard/src/pages/McpPage.tsx, dashboard/src/pages/PluginsPage.tsx, dashboard/src/pages/MarketplacesPage.tsx, dashboard/src/pages/HooksPage.tsx, dashboard/src/pages/AgentsPage.tsx, dashboard/src/pages/SkillsPage.tsx, dashboard/src/pages/PermissionsPage.tsx, dashboard/src/pages/HealthPage.tsx, dashboard/src/pages/ProjectsPage.tsx</files>
  <action>
    **Step 1: Create RefreshContext (new file)**

    Create `dashboard/src/lib/refresh-context.tsx` with:
    ```
    - RefreshContext with value: { refreshKey: number, triggerRefresh: () => void, isRefreshing: boolean, setRefreshing: (v: boolean) => void }
    - RefreshProvider component: useState for refreshKey (starts at 0), isRefreshing (starts at false)
      - triggerRefresh increments refreshKey
      - Wraps children in RefreshContext.Provider
    - useRefresh() hook: useContext(RefreshContext) with error if used outside provider
    ```

    **Step 2: Wire RefreshProvider into App**

    In `dashboard/src/App.tsx`:
    - Import RefreshProvider
    - Wrap `<BrowserRouter>` contents with `<RefreshProvider>` (inside BrowserRouter, outside Routes)

    **Step 3: Add header bar with refresh button to Layout**

    In `dashboard/src/components/Layout.tsx`:
    - Import `useRefresh` from `../lib/refresh-context`
    - Add a header bar INSIDE the `<main>` element, BEFORE the `<Outlet />`
    - Header: `<div className="flex items-center justify-end mb-4">` (right-aligned)
    - Refresh button: `<button>` with a refresh/arrow-path icon (Heroicons)
      - On click: call `triggerRefresh()`
      - When `isRefreshing`: add `animate-spin` to the icon, disable the button
      - Style: `text-slate-400 hover:text-slate-600 p-2 rounded-lg hover:bg-slate-100 transition-colors disabled:opacity-50`
      - Title: "Refresh data"
    - Keep existing Layout structure (flex, sidebar, main) — just add the header row inside main
    - DO NOT modify the existing mobile header in Sidebar.tsx. The refresh button goes in the main content area header only.

    **Step 4: Wire all 12 page components to use RefreshContext**

    For EACH page in dashboard/src/pages/:

    1. Import `useRefresh` from `../lib/refresh-context`
    2. At top of component: `const { refreshKey, setRefreshing } = useRefresh();`
    3. Find the main `useEffect` that fetches data (the one with `[]` dependency array)
    4. Change dependency array from `[]` to `[refreshKey]`
    5. Add `setRefreshing(true)` at the START of the async function inside useEffect
    6. Add `setRefreshing(false)` in the finally/completion of the fetch (both success and error paths)
    7. Keep all existing fetch logic, error handling, and loading states as-is

    **Pattern for each page (example with OverviewPage):**
    ```tsx
    const { refreshKey, setRefreshing } = useRefresh();

    useEffect(() => {
      let cancelled = false;
      setRefreshing(true);

      async function loadData() {
        try {
          // ... existing fetch logic ...
          if (cancelled) return;
          // ... existing state updates ...
          setLoading(false);
        } catch (err) {
          if (cancelled) return;
          setError(err instanceof Error ? err.message : "Failed to load data");
          setLoading(false);
        } finally {
          if (!cancelled) setRefreshing(false);
        }
      }

      loadData();
      return () => { cancelled = true; };
    }, [refreshKey]);
    ```

    **When refreshKey changes (user clicks refresh):**
    - Set page loading state back to true at the top of the effect (before the async function starts)
    - This shows the page's existing loading skeleton/spinner
    - Reset error state to null

    **Special cases:**
    - OverviewPage: Has `setLoading(true)` — add it back at effect start (already starts true from useState default, but need it for re-fetches)
    - ProjectsPage: May have different fetch pattern (workspace discovery) — adapt similarly, add refreshKey to dependency
    - Pages with no useEffect data fetch: unlikely, but if found, just add the import and destructure (no-op)
  </action>
  <verify>npm run build succeeds. Start server, open dashboard, click refresh button — page data reloads and button shows spinning animation.</verify>
  <done>
    - RefreshContext created with refreshKey + isRefreshing + triggerRefresh + setRefreshing
    - App.tsx wraps routes with RefreshProvider
    - Layout.tsx has header with refresh button that spins during fetch
    - All 12 pages consume refreshKey and report loading state via setRefreshing
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Grouped sidebar navigation and global refresh button</what-built>
  <how-to-verify>
    1. Run: node dist/index.js dashboard
    2. Visit: http://localhost:3737
    3. Sidebar: Verify "Overview" at top (ungrouped), then "CONFIGURATION" header with Settings/Memory/Permissions, then "EXTENSIONS" header with MCP Servers/Plugins/Marketplaces/Hooks/Agents/Skills, then "WORKSPACE" header with Health/Projects
    4. Click between different pages — active highlight still works correctly
    5. Header: Verify refresh button (arrow/circle icon) visible at top-right of content area
    6. Click refresh: Button spins, page data reloads (may see brief loading skeleton), button stops spinning
    7. Navigate to different page, click refresh again — works on every page
    8. Mobile: Open hamburger menu — sidebar groups should be visible with section headers
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds (tsup + Vite, zero errors)
- [ ] `npm test` passes all existing tests
- [ ] Sidebar shows 3 section headers with correct item grouping
- [ ] Refresh button visible and functional on all pages
- [ ] Refresh button shows loading indicator during data fetch
- [ ] No regressions in existing page functionality
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Sidebar items grouped under Configuration, Extensions, Workspace headers
- Overview remains ungrouped at top
- Refresh button triggers re-fetch on active page
- Refresh button shows spinning state during fetch
- Mobile sidebar still works with groups
</success_criteria>

<output>
After completion, create `.planning/phases/08-dashboard-layout/08-01-SUMMARY.md`
</output>
