---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - tsup.config.ts
  - src/index.ts
  - src/scanner/index.ts
  - src/scanner/paths.ts
  - src/scanner/parser.ts
  - src/scanner/types.ts
autonomous: true

must_haves:
  truths:
    - "Scanner discovers settings.json files at all four scope levels (managed, user, project, local)"
    - "Scanner discovers CLAUDE.md files at project root and .claude/ directory"
    - "Scanner discovers commands directories at global and project level"
    - "JSONC files with comments and trailing commas parse correctly"
    - "Missing or inaccessible files produce structured error results, not crashes"
    - "Path resolution works on Windows (backslashes, USERPROFILE) and Unix (forward slashes, HOME)"
  artifacts:
    - path: "package.json"
      provides: "Project metadata, dependencies, bin entry"
      contains: "claude-ctl"
    - path: "tsconfig.json"
      provides: "TypeScript configuration"
    - path: "tsup.config.ts"
      provides: "Build configuration for CLI bundle"
    - path: "src/scanner/paths.ts"
      provides: "Cross-platform config path resolution"
      exports: ["getConfigPaths"]
    - path: "src/scanner/parser.ts"
      provides: "JSONC file parsing with error handling"
      exports: ["parseJsonc"]
    - path: "src/scanner/index.ts"
      provides: "Core scanning engine that discovers config files"
      exports: ["scan"]
    - path: "src/scanner/types.ts"
      provides: "Shared type definitions for scanner results"
      exports: ["ScanResult", "ConfigFile", "ConfigScope"]
  key_links:
    - from: "src/scanner/index.ts"
      to: "src/scanner/paths.ts"
      via: "getConfigPaths provides locations to scan"
      pattern: "getConfigPaths"
    - from: "src/scanner/index.ts"
      to: "src/scanner/parser.ts"
      via: "parseJsonc reads JSON/JSONC config files"
      pattern: "parseJsonc"
---

<objective>
Set up the project from scratch and build the core scanning engine that discovers all Claude Code configuration files across global and project directories.

Purpose: This is the foundation everything else builds on. The scanner provides the data layer that CLI commands and later the web dashboard will consume.
Output: A buildable TypeScript project with a working scanner that returns structured data about all discovered config files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project scaffolding with build pipeline</name>
  <files>package.json, tsconfig.json, tsup.config.ts, src/index.ts, .gitignore</files>
  <action>
    Initialize the project:

    1. Create `package.json`:
       - name: "claude-control"
       - bin: { "claude-ctl": "./dist/index.js" }
       - type: "module"
       - scripts: build (tsup), dev (tsup --watch), typecheck (tsc --noEmit)
       - dependencies: commander, jsonc-parser, chalk
       - devDependencies: tsup, typescript, @types/node

    2. Create `tsconfig.json`:
       - target: ES2022, module: ESNext, moduleResolution: bundler
       - strict: true, outDir: dist, rootDir: src
       - include: ["src/**/*"]

    3. Create `tsup.config.ts`:
       - entry: ["src/index.ts"]
       - format: ["esm"]
       - target: "node18"
       - clean: true
       - banner with #!/usr/bin/env node shebang for the bin entry

    4. Create `src/index.ts`:
       - Placeholder CLI entry point that imports and runs the CLI
       - Just enough to verify the build works

    5. Create `.gitignore`:
       - node_modules/, dist/, *.tgz

    6. Run `npm install` to install dependencies

    7. Run `npm run build` to verify the pipeline works

    **Important:** Use `jsonc-parser` (Microsoft's VS Code parser), NOT `strip-json-comments`. It handles both comments AND trailing commas natively. Use chalk v5+ (ESM-native).
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `dist/index.js` exists and starts with shebang
    - `npm run typecheck` passes
  </verify>
  <done>Project builds successfully, all dependencies installed, bin entry configured</done>
</task>

<task type="auto">
  <name>Task 2: Implement cross-platform config path resolver and types</name>
  <files>src/scanner/types.ts, src/scanner/paths.ts</files>
  <action>
    1. Create `src/scanner/types.ts` with these types:

       ```
       ConfigScope: "managed" | "user" | "project" | "local"

       ConfigFileType: "settings" | "claude-md" | "commands-dir" | "mcp" | "hooks" | "credentials" | "keybindings"

       ConfigFileExpectation:
         - scope: ConfigScope
         - type: ConfigFileType
         - expectedPath: string (absolute path)
         - description: string (human-readable, e.g. "User-level settings")

       ConfigFile:
         - ...ConfigFileExpectation
         - exists: boolean
         - readable: boolean
         - error?: string (e.g. "Permission denied", "Malformed JSON")
         - content?: unknown (parsed content for JSON/JSONC files, raw string for .md)
         - sizeBytes?: number

       ScanResult:
         - timestamp: string (ISO 8601)
         - projectDir: string | null
         - globalDir: string
         - files: ConfigFile[]
         - summary: { total: number, found: number, missing: number, errors: number }
       ```

    2. Create `src/scanner/paths.ts`:

       Export `getConfigPaths(projectDir?: string): ConfigFileExpectation[]`

       This function returns ALL expected Claude Code config file locations:

       **Global paths (derive from home directory):**
       - `~/.claude/settings.json` (scope: "user", type: "settings")
       - `~/.claude/credentials.json` (scope: "user", type: "credentials") — note: we'll report exists/missing but NEVER read content
       - `~/.claude/keybindings.json` (scope: "user", type: "keybindings")
       - `~/.claude/commands/` (scope: "user", type: "commands-dir")

       **Project paths (only if projectDir provided):**
       - `{projectDir}/.claude/settings.json` (scope: "project", type: "settings")
       - `{projectDir}/.claude/settings.local.json` (scope: "local", type: "settings")
       - `{projectDir}/CLAUDE.md` (scope: "project", type: "claude-md")
       - `{projectDir}/.claude/CLAUDE.md` (scope: "project", type: "claude-md")
       - `{projectDir}/.claude/commands/` (scope: "project", type: "commands-dir")

       **Cross-platform home directory detection:**
       - Windows: Use `process.env.USERPROFILE` (fallback to `process.env.HOME`)
       - Unix: Use `process.env.HOME`
       - Use `path.join()` for all path construction (never string concatenation with separators)
       - Use `os.homedir()` as primary source, env vars as fallback

       **Important:** Do NOT hardcode path separators. Always use `path.join()` and `path.resolve()`.
  </action>
  <verify>
    - `npm run typecheck` passes
    - Types are exported correctly
    - `getConfigPaths()` returns global paths
    - `getConfigPaths("/some/project")` returns global + project paths
  </verify>
  <done>Path resolver returns correct expected locations for all platforms, types fully defined</done>
</task>

<task type="auto">
  <name>Task 3: Implement JSONC parser and core scanner</name>
  <files>src/scanner/parser.ts, src/scanner/index.ts</files>
  <action>
    1. Create `src/scanner/parser.ts`:

       Export `parseJsonc(filePath: string): Promise<{ data: unknown; errors: string[] }>`

       - Read file content with `fs.readFile` (utf-8)
       - Use `jsonc-parser`'s `parse()` function to handle comments and trailing commas
       - Collect parse errors from jsonc-parser's error callback
       - Return parsed data and any non-fatal parse errors
       - On file read error, throw with descriptive message

       Export `readMarkdown(filePath: string): Promise<string>`
       - Read .md file content as string
       - Simple fs.readFile wrapper with error handling

    2. Create `src/scanner/index.ts`:

       Export `scan(projectDir?: string): Promise<ScanResult>`

       Implementation:
       - Call `getConfigPaths(projectDir)` to get all expected locations
       - For each expected path:
         - Check if it exists (`fs.access`)
         - If it's a directory type (commands-dir), check with `fs.stat` for directory
         - If it exists and is a .json file, parse with `parseJsonc()`
         - If it exists and is a .md file, read with `readMarkdown()`
         - If it's credentials.json, set exists=true but do NOT read content (security)
         - Catch all errors per-file (permission denied, etc.) — never let one file crash the whole scan
       - Build and return `ScanResult` with summary counts

       **Error handling strategy:**
       - Each file is scanned independently — one failure doesn't affect others
       - Errors are captured in the `ConfigFile.error` field
       - Permission denied → error: "Permission denied"
       - Malformed JSONC → error: "Parse error: {details}" (still sets exists: true)
       - Missing file → exists: false, readable: false (not an error, just missing)

       **Security:** Never read or store credentials.json content. Only report exists/missing.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm run build` succeeds
    - Scanner can be imported and called: add a quick smoke test in a temp file that calls `scan()` and logs result
  </verify>
  <done>Scanner discovers all expected config files, parses JSONC correctly, handles all error cases gracefully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run typecheck` passes with no errors
- [ ] Scanner correctly discovers global config files on the current system
- [ ] JSONC parsing handles comments and trailing commas
- [ ] Missing files produce structured results (exists: false), not crashes
- [ ] All types are exported and usable
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Project builds and type-checks cleanly
- Scanner returns accurate ScanResult for current system
- No security issues (credentials content never stored)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
