---
phase: 02-config-viewers-settings
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/settings/types.ts
  - src/settings/resolver.ts
  - src/settings/resolver.test.ts
  - package.json
  - vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Resolver merges settings from all four scopes with correct priority (local > project > user > managed)"
    - "Each resolved setting tracks which scope it originated from and which file path"
    - "Override chain shows all scope values for keys defined at multiple levels"
    - "Missing scopes are handled gracefully (not all scopes need to exist)"
    - "Empty settings objects produce empty results"
  artifacts:
    - path: "src/settings/types.ts"
      provides: "ScopedSettings, ResolvedSetting, SettingsResult type definitions"
      min_lines: 20
    - path: "src/settings/resolver.ts"
      provides: "resolveSettings function with merge and source tracking logic"
      exports: ["resolveSettings"]
      min_lines: 30
    - path: "src/settings/resolver.test.ts"
      provides: "Tests for settings resolution covering merge, override, edge cases"
      min_lines: 50
  key_links:
    - from: "src/settings/resolver.ts"
      to: "src/settings/types.ts"
      via: "imports ScopedSettings, ResolvedSetting, SettingsResult types"
    - from: "src/settings/resolver.ts"
      to: "src/scanner/types.ts"
      via: "uses ConfigScope type for scope tracking"
---

<objective>
Implement the settings resolver — the core business logic that merges settings from all four Claude Code scope levels and tracks where each value comes from.

Purpose: This resolver is the engine behind `claude-ctl settings`. It takes raw parsed settings from each scope and produces a merged view with full source tracking. TDD ensures the merge priority logic is correct.
Output: Working, tested resolveSettings() function with types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/scanner/types.ts
</context>

<feature>
  <name>Settings resolver with scope-aware merge</name>
  <files>src/settings/types.ts, src/settings/resolver.ts, src/settings/resolver.test.ts</files>
  <behavior>
    resolveSettings(scoped: ScopedSettings[]) → SettingsResult

    Input: Array of ScopedSettings, each containing:
      - scope: ConfigScope ("managed" | "user" | "project" | "local")
      - path: string (source file path)
      - settings: Record&lt;string, unknown&gt; (parsed settings object)

    Priority: local > project > user > managed
    (Later scope in priority order overrides earlier)

    Output: SettingsResult containing:
      - settings: ResolvedSetting[] (one per unique top-level key)
      - Each ResolvedSetting has:
        - key: string (top-level setting key)
        - effectiveValue: unknown (value from highest-priority scope)
        - effectiveScope: ConfigScope (which scope the effective value comes from)
        - effectiveSourcePath: string (file path of the winning scope)
        - overrides: Array of { scope, path, value } for all scopes defining this key
          (sorted by priority, highest first)

    Test cases:
      1. Single scope, single key → effective value from that scope
      2. Two scopes, no key overlap → both keys in result
      3. Two scopes, same key → higher priority scope wins
      4. All four scopes, same key → local wins, all four in overrides
      5. Mixed: some keys shared, some unique → correct merge
      6. Empty scoped array → empty result
      7. Scope with empty settings object → no keys contributed
      8. Nested object value → treated as opaque value (not deep merged)
      9. Settings sorted alphabetically by key
  </behavior>
  <implementation>
    1. Define priority order: ["managed", "user", "project", "local"] (index = priority)
    2. Collect all unique keys across all scoped settings
    3. For each key, find all scopes that define it
    4. Sort by scope priority (highest first)
    5. effectiveValue = value from highest-priority scope
    6. overrides = all scope values sorted by priority (highest first)
    7. Return results sorted alphabetically by key

    Test framework setup (RED phase):
    - Install vitest as dev dependency
    - Create vitest.config.ts with basic config
    - Add "test" script to package.json
  </implementation>
</feature>

<verification>
- `npm test` passes all resolver tests
- `npm run typecheck` passes with new types
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- All 2-3 commits present
- resolveSettings function exported and usable
</success_criteria>

<output>
After completion, create `.planning/phases/02-config-viewers-settings/02-01-SUMMARY.md`
</output>
