---
phase: 05-advanced-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/memory/types.ts
  - src/memory/resolver.ts
  - src/commands/memory.ts
  - src/formatters/memory.ts
  - src/server/routes.ts
autonomous: true

must_haves:
  truths:
    - "User can see which @import directives exist in each CLAUDE.md file"
    - "User can see whether each imported file exists or is broken"
    - "User can see the full import dependency chain (which file imports which)"
    - "Circular imports are detected and reported without crashing"
  artifacts:
    - path: "src/memory/types.ts"
      provides: "MemoryImport, ResolvedMemoryFile, MemoryImportResult types"
      min_lines: 20
    - path: "src/memory/resolver.ts"
      provides: "@import parsing, path resolution, chain traversal, circular detection"
      min_lines: 60
  key_links:
    - from: "src/memory/resolver.ts"
      to: "src/scanner/parser.ts"
      via: "readMarkdown for imported file content"
      pattern: "readMarkdown"
    - from: "src/server/routes.ts"
      to: "src/memory/resolver.ts"
      via: "GET /api/memory/imports endpoint"
      pattern: "api/memory/imports"
---

<objective>
Build CLAUDE.md @import resolver that parses import directives, resolves paths, traverses dependency chains, and detects broken/circular imports.

Purpose: Users need visibility into how their CLAUDE.md files compose via @import — which files are pulled in, which are broken, and how deep the chain goes. This completes CLMD-03.
Output: New `src/memory/` module with types and resolver, updated CLI memory command with --imports flag, new API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/scanner/types.ts
@src/scanner/parser.ts
@src/commands/memory.ts
@src/server/routes.ts
@src/formatters/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory import types and resolver</name>
  <files>src/memory/types.ts, src/memory/resolver.ts</files>
  <action>
    1. Create `src/memory/types.ts` with types:
       ```typescript
       interface MemoryImport {
         raw: string;              // the @import text as found
         resolvedPath: string;     // absolute path after resolution
         relativeTo: string;       // which file contained this import
         exists: boolean;          // file exists on disk
         error?: string;           // read error if any
       }

       interface ResolvedMemoryFile {
         path: string;
         scope: ConfigScope;
         imports: MemoryImport[];
         importChain: string[];    // ordered list of resolved import paths
         hasCircular: boolean;
         circularAt?: string;      // path where circular was detected
       }

       interface MemoryImportResult {
         files: ResolvedMemoryFile[];
         brokenImports: MemoryImport[];  // imports where exists === false
         totalImports: number;
         totalBroken: number;
       }
       ```

    2. Create `src/memory/resolver.ts`:
       - Export `resolveMemoryImports(files: ConfigFile[]): Promise<MemoryImportResult>`
       - Filter for `type === "claude-md"` files that exist and have string content
       - For each CLAUDE.md file, parse @import directives from content:
         - Pattern: `@` followed by a path-like string (not inside code blocks)
         - Match: lines or inline references matching `@[./~][^\s]+\.md` or `@[a-zA-Z][^\s]+\.md`
         - Skip: `@` references inside triple-backtick code blocks (track code block state while scanning lines)
         - Skip: `@` that looks like an email or username (contains no `/` and no `.md` extension)
       - Resolve each import path:
         - Relative paths (`@./foo.md`, `@../bar.md`): resolve relative to the containing CLAUDE.md's directory
         - Home paths (`@~/.claude/foo.md`): expand `~` via `os.homedir()`
         - Absolute paths (`@/foo/bar.md`): use as-is
         - Bare paths (`@docs/foo.md`): resolve relative to containing file's directory
       - Check existence with `fs.access()`
       - Traverse import chain up to 5 levels deep (matching Claude Code's limit)
       - Detect circular imports: track visited set per chain, if revisited mark `hasCircular: true`
       - Collect all broken imports into `brokenImports` array

    Design notes:
    - Do NOT read imported file content into the result (could be huge). Just track paths and existence.
    - The resolver pattern follows existing extractMcpServers / resolvePermissions patterns.
    - Use `path.resolve(path.dirname(containingFile), importPath)` for relative resolution.
    - Be generous with path matching — it's better to detect a potential import and mark it broken than miss it.
  </action>
  <verify>
    `npm run build` succeeds.
    Types are importable from `src/memory/types.ts`.
    Resolver function is exported from `src/memory/resolver.ts`.
  </verify>
  <done>
    Memory import resolver parses @import directives, resolves paths, checks existence, detects circulars, and returns structured result.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire import resolver to CLI and API</name>
  <files>src/commands/memory.ts, src/formatters/memory.ts, src/formatters/index.ts, src/server/routes.ts, src/index.ts</files>
  <action>
    1. Update `src/commands/memory.ts`:
       - Add `--imports` flag to the memory command
       - When `--imports` is passed, call `resolveMemoryImports(result.files)` and format output
       - Show: each CLAUDE.md file, its imports (with exists/broken status), chain depth, any circulars

    2. Create `src/formatters/memory.ts` (or add to existing formatter):
       - `formatMemoryImports(result: MemoryImportResult, projectDir: string, json: boolean): string`
       - Table format: list each CLAUDE.md, its imports with green checkmark (exists) or red X (broken), chain visualization
       - JSON format: pass through the MemoryImportResult
       - Show summary: "N imports total, N broken"

    3. Update `src/formatters/index.ts`:
       - Export the new `formatMemoryImports` function

    4. Add API endpoint in `src/server/routes.ts`:
       - `GET /api/memory/imports` — calls scan + resolveMemoryImports, returns JSON

    5. Update `src/index.ts` if needed for the `--imports` option.

    Design notes:
    - Follow existing command pattern: scan → filter → resolve → format → output
    - Broken imports should be visually distinct (red in table, `exists: false` in JSON)
    - Chain depth shown as indentation or breadcrumb trail
  </action>
  <verify>
    `npm run build` succeeds.
    `node dist/index.js memory --imports` runs without error (may show empty if no CLAUDE.md files have imports).
    `node dist/index.js memory --imports --json` produces valid JSON.
    API endpoint `/api/memory/imports` returns JSON response.
  </verify>
  <done>
    CLI `memory --imports` shows import chain analysis.
    API `/api/memory/imports` returns import resolution data.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `src/memory/types.ts` exports all import-related types
- [ ] `src/memory/resolver.ts` exports `resolveMemoryImports`
- [ ] `memory --imports` runs and produces table output
- [ ] `memory --imports --json` produces valid JSON
- [ ] `/api/memory/imports` returns JSON from running server
- [ ] Code handles: no CLAUDE.md files, no imports, broken imports, circular imports
</verification>

<success_criteria>
- All tasks completed
- Import resolver correctly parses @import syntax from CLAUDE.md content
- Broken imports identified with clear error info
- Circular imports detected without infinite loops
- CLI and API both expose import data
</success_criteria>

<output>
After completion, create `.planning/phases/05-advanced-features/05-01-SUMMARY.md`
</output>
